# Отслеживание состояния пользователя

## Обзор

Система контроля доступа отслеживает текущее местоположение каждого пользователя в зонах с помощью таблицы `user_state`. Состояние пользователя обновляется при успешных переходах между зонами и использует оптимистичную блокировку (optimistic locking) для предотвращения гонок данных при конкурентных обновлениях.

## Структура таблицы user_state

Таблица `user_state` содержит следующие поля:

- `id` (UUID) — первичный ключ
- `user_id` (UUID, UNIQUE) — идентификатор пользователя (FK → `users.id`)
- `current_zone_id` (UUID, nullable) — текущая зона пользователя (FK → `zones.id`)
  - `NULL` означает, что пользователь находится вне системы (OUT zone)
- `version` (BIGINT) — версия записи для оптимистичной блокировки (начинается с 0)
- `updated_at` (TIMESTAMPTZ) — время последнего обновления

## Инварианты состояния

### Зона OUT (вне системы)

- **Значение:** `current_zone_id = NULL`
- **Семантика:** Пользователь находится вне системы контроля доступа
- **Инициализация:** При первом создании записи состояния пользователя, если не указана начальная зона
- **Переходы:** 
  - Пользователь может войти в систему через пропускной пункт, если есть правило доступа с `from_zone_id = NULL` и соответствующим `to_zone_id`
  - При выходе пользователя из системы состояние обновляется на `NULL`

### Вход в систему (Entry)

- **Переход:** `OUT (NULL)` → `Zone X`
- **Условие:** Должно существовать правило доступа с `from_zone_id = NULL` и `to_zone_id = Zone X`
- **Валидация состояния:** Система проверяет, что пользователь находится в OUT зоне (`current_zone_id = NULL`)
  - Если пользователь уже находится в какой-либо зоне, переход отклоняется с причиной `STATE_MISMATCH`
- **Обновление состояния:** После успешной проверки доступа и состояния, `current_zone_id` устанавливается в `Zone X`, `version` инкрементируется

### Выход из системы (Exit)

- **Переход:** `Zone X` → `OUT (NULL)`
- **Условие:** Должно существовать правило доступа с `from_zone_id = Zone X` и `to_zone_id = NULL`
- **Валидация состояния:** Система проверяет, что пользователь находится в `Zone X` (сравнивая `current_zone_id` с `from_zone_id` из события)
  - Если текущая зона пользователя не совпадает с `from_zone_id`, переход отклоняется с причиной `STATE_MISMATCH`
  - Если правило доступа для выхода отсутствует, переход отклоняется с причиной `ACCESS_DENIED`
- **Обновление состояния:** После успешной проверки доступа и состояния, `current_zone_id` устанавливается в `NULL`, `version` инкрементируется

### Переход между зонами (Transit)

- **Переход:** `Zone X` → `Zone Y`
- **Условие:** Должно существовать правило доступа с `from_zone_id = Zone X` и `to_zone_id = Zone Y`
- **Валидация состояния:** Система проверяет, что пользователь действительно находится в `Zone X` (сравнивая `current_zone_id` с `from_zone_id` из события)
  - Если текущая зона пользователя не совпадает с `from_zone_id`, переход отклоняется с причиной `STATE_MISMATCH`
  - Пользователь не может совершить переход из зоны, в которой он не находится
  - Пользователь не может совершить переход из зоны, в которую не заходил ранее (его текущая зона должна совпадать с исходной зоной перехода)
- **Обновление состояния:** После успешной проверки доступа и состояния, `current_zone_id` устанавливается в `Zone Y`, `version` инкрементируется

## Оптимистичная блокировка

### Механизм

Система использует оптимистичную блокировку на основе поля `version` для предотвращения гонок данных:

1. **Чтение:** При получении текущего состояния пользователя, система также получает текущее значение `version`
2. **Обновление:** При обновлении зоны, система проверяет, что `version` в базе данных совпадает с ожидаемым значением
3. **Успех:** Если версии совпадают, обновление выполняется и `version` инкрементируется
4. **Конфликт:** Если версии не совпадают (другая транзакция уже обновила состояние), возникает `OptimisticLockingFailureException`

### Пример работы

```sql
-- Шаг 1: Чтение текущего состояния
SELECT current_zone_id, version FROM user_state WHERE user_id = ?;
-- Результат: current_zone_id = 'zone-a', version = 5

-- Шаг 2: Попытка обновления с проверкой версии
UPDATE user_state 
SET current_zone_id = 'zone-b', version = version + 1
WHERE user_id = ? AND version = 5;
-- Если версия все еще 5, обновление успешно (version становится 6)
-- Если версия уже 6 (другая транзакция обновила), обновление не выполняется (0 строк)
```

### Обработка конфликтов

Сервис `UserStateService` обрабатывает конфликты версий следующим образом:

1. **Повторные попытки:** При конфликте версии, сервис делает до 3 попыток с небольшими задержками
2. **Экспоненциальная задержка:** Задержка между попытками увеличивается (10ms, 20ms, 30ms)
3. **Исключение:** Если все попытки исчерпаны, выбрасывается `OptimisticLockingFailureException`

### Преимущества оптимистичной блокировки

- **Производительность:** Не блокирует чтение, только запись при конфликте
- **Масштабируемость:** Работает эффективно при низком уровне конфликтов
- **Простота:** Не требует явных блокировок на уровне базы данных

## API сервиса

### UserStateService

```java
@Service
public class UserStateService implements AccessControlContracts.UserStateService {
    
    ZoneId currentZone(UserId userId);
    void updateZone(UserId userId, ZoneId newZone);
}
```

### Методы

#### currentZone()

Получает текущую зону пользователя.

**Параметры:**
- `userId` — идентификатор пользователя

**Возвращает:**
- `ZoneId` — текущая зона пользователя, или `null` если пользователь в OUT zone или состояние не инициализировано

**Пример:**
```java
UserId userId = new UserId("user-1");
ZoneId currentZone = userStateService.currentZone(userId);
if (currentZone == null) {
    // Пользователь вне системы
} else {
    // Пользователь в зоне currentZone.value()
}
```

#### updateZone()

Обновляет текущую зону пользователя с оптимистичной блокировкой.

**Параметры:**
- `userId` — идентификатор пользователя
- `newZone` — новая зона (может быть `null` для OUT zone)

**Исключения:**
- `OptimisticLockingFailureException` — если все попытки обновления исчерпаны из-за конфликтов версий

**Пример:**
```java
UserId userId = new UserId("user-1");
ZoneId newZone = new ZoneId("zone-a");
userStateService.updateZone(userId, newZone);

// Выход из системы
userStateService.updateZone(userId, null);
```

### UserStateRepository

```java
@Repository
public interface UserStateRepository {
    Optional<UserStateRecord> getCurrentZone(String userCode);
    boolean updateZone(String userCode, String zoneCode, long expectedVersion);
    boolean initializeState(String userCode, String zoneCode);
}
```

## Интеграция с TransactionalEventProcessingService

`UserStateService` интегрирован в `TransactionalEventProcessingService` для проверки состояния и автоматического обновления при успешных переходах:

```java
// В TransactionalEventProcessingService.processEvent()
// 1. Проверка правил доступа
AccessDecision decision = accessRuleEvaluator.canTransit(
    userIdObj, fromZoneObj, toZoneObj
);

if (decision != ALLOW) {
    // Отклонение при отсутствии правила доступа
    return ProcessingResult.denied("access_denied", ...);
}

// 2. Проверка текущего состояния пользователя
ZoneId currentZone = userStateService.currentZone(userIdObj);
boolean stateMatches;
if (fromZoneObj == null) {
    // Вход извне: пользователь должен быть в OUT зоне
    stateMatches = (currentZone == null);
} else {
    // Переход между зонами: текущая зона должна совпадать с fromZone
    stateMatches = (currentZone != null && currentZone.value().equals(fromZoneObj.value()));
}

if (!stateMatches) {
    // Отклонение при несоответствии состояния
    return ProcessingResult.denied("state_mismatch", ...);
}

// 3. Обновление состояния только при успешных проверках
userStateService.updateZone(userIdObj, toZoneObj);
```

Порядок проверок:
1. **Правила доступа** — проверяется наличие правила для перехода
2. **Состояние пользователя** — проверяется, что пользователь находится в правильной исходной зоне
3. **Обновление состояния** — выполняется только если обе проверки успешны

## Инициализация состояния

Состояние пользователя инициализируется автоматически при первом обновлении:

1. Если запись `user_state` не существует, сервис автоматически создает ее с `version = 0`
2. Если запись существует, обновление происходит с проверкой версии

## Примеры использования

### Пример 1: Вход пользователя в систему

```java
// Пользователь входит в zone-a извне
UserId userId = new UserId("user-1");
ZoneId entryZone = new ZoneId("zone-a");

// Проверка доступа (выполняется в AccessService)
AccessDecision decision = accessRuleEvaluator.canTransit(userId, null, entryZone);
if (decision == ALLOW) {
    // Обновление состояния
    userStateService.updateZone(userId, entryZone);
    // Теперь currentZone(userId) вернет zone-a
}
```

### Пример 2: Переход между зонами

```java
// Пользователь переходит из zone-a в zone-b
UserId userId = new UserId("user-1");
ZoneId fromZone = new ZoneId("zone-a");
ZoneId toZone = new ZoneId("zone-b");

// Проверка доступа
AccessDecision decision = accessRuleEvaluator.canTransit(userId, fromZone, toZone);
if (decision == ALLOW) {
    // Обновление состояния
    userStateService.updateZone(userId, toZone);
    // Теперь currentZone(userId) вернет zone-b
}
```

### Пример 3: Выход из системы

```java
// Пользователь выходит из системы
UserId userId = new UserId("user-1");

// Обновление состояния на OUT
userStateService.updateZone(userId, null);
// Теперь currentZone(userId) вернет null (OUT zone)
```

## Индексы для производительности

Таблица содержит следующие индексы:

- `idx_user_state_user` — быстрый поиск по `user_id`
- `idx_user_state_zone` — поиск пользователей в конкретной зоне

## Тестирование

Тесты для `UserStateService` включают:

1. **Базовые операции:** Инициализация, чтение, обновление состояния
2. **Оптимистичная блокировка:** Тесты конкурентных обновлений с проверкой предотвращения гонок
3. **OUT zone:** Тесты работы с состоянием "вне системы"
4. **Версионирование:** Проверка корректного инкрементирования версии

См. `UserStateServiceTest` для примеров тестов.

## Рекомендации по использованию

1. **Инициализация:** Состояние инициализируется автоматически при первом обновлении, нет необходимости в ручной инициализации

2. **Конкурентность:** Система обрабатывает конкурентные обновления через оптимистичную блокировку, но при очень высокой нагрузке может потребоваться дополнительная оптимизация

3. **OUT zone:** Используйте `null` для представления состояния "вне системы" — это согласуется с правилами доступа, где `from_zone_id = NULL` означает вход извне

4. **Валидация:** Система проверяет, что пользователь находится в правильной исходной зоне перед переходом, что предотвращает несанкционированные переходы

5. **Производительность:** Индексы оптимизируют поиск состояния пользователя, но при большом количестве пользователей рекомендуется мониторинг производительности запросов

## Безопасность

- **Целостность данных:** Оптимистичная блокировка предотвращает потерю обновлений при конкурентных транзакциях
- **Валидация состояния:** Система проверяет соответствие текущего состояния пользователя запрашиваемому переходу
- **Атомарность:** Обновления выполняются в транзакциях, обеспечивая целостность данных

