# Криптография и проверка подписей

## Обзор

Система использует цифровые подписи для проверки подлинности сообщений от пропускных пунктов. Каждый пропускной пункт имеет пару ключей (закрытый и открытый), и подписывает все отправляемые события своим закрытым ключом.

## Формат подписи

### Поддерживаемые алгоритмы

- **RSA** с SHA-256 (`SHA256withRSA`)
- **ECDSA** с SHA-256 (`SHA256withECDSA`)

### Каноническая форма payload

Для обеспечения детерминированности и предотвращения проблем с порядком полей, все события приводятся к канонической форме перед подписанием.

**Формат канонической формы:**
```
checkpointId|timestamp|fromZone|toZone|userToken
```

**Правила:**
- Все поля разделяются символом `|` (вертикальная черта)
- Порядок полей строго фиксирован: `checkpointId`, затем `timestamp`, затем `fromZone`, затем `toZone`, затем `userToken`
- Кодировка: UTF-8
- Поля не экранируются (в текущей версии не допускаются значения, содержащие `|`)

**Пример:**
```
cp-1|2025-01-01T12:00:00Z|zone-a|zone-b|token123
```

### Формат подписанного payload

Подписанный payload передаётся в следующем формате:

```
base64(canonical_payload)|base64(signature)
```

Где:
- `canonical_payload` - каноническая форма события в байтах (UTF-8)
- `signature` - цифровая подпись канонической формы в байтах

**Пример:**
```
Y3AtMXwyMDI1LTAxLTAxVDEyOjAwOjAwWnx6b25lLWF8em9uZS1ifHRva2VuMTIz|ABC123...XYZ789
```

## Хранение ключей

### Структура таблицы `checkpoint_keys`

```sql
CREATE TABLE checkpoint_keys (
    id              UUID PRIMARY KEY,
    checkpoint_code VARCHAR(128) NOT NULL UNIQUE,
    public_key_pem  TEXT         NOT NULL,
    key_type        VARCHAR(20)  NOT NULL DEFAULT 'RSA',
    created_at      TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
    updated_at      TIMESTAMPTZ  NOT NULL DEFAULT NOW()
);
```

### Формат публичного ключа (PEM)

Публичные ключи хранятся в формате PEM (Privacy-Enhanced Mail):

**RSA:**
```
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
-----END PUBLIC KEY-----
```

**ECDSA:**
```
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE...
-----END PUBLIC KEY-----
```

## Процесс проверки подписи

1. **Получение события**: Система получает POST-запрос на `/ingest/event` с JSON-телом, содержащим:
   - `checkpointId` - идентификатор пропускного пункта
   - `timestamp` - время события (ISO-8601 UTC)
   - `fromZone` - исходная зона
   - `toZone` - целевая зона
   - `userToken` - зашифрованный токен пользователя
   - `signature` - base64-кодированная подпись

2. **Построение канонической формы**: Система строит каноническую форму из полей запроса:
   ```
   canonical = checkpointId + "|" + timestamp + "|" + fromZone + "|" + toZone + "|" + userToken
   ```

3. **Получение публичного ключа**: По `checkpointId` извлекается публичный ключ из таблицы `checkpoint_keys`.

4. **Верификация подписи**:
   - Декодируется base64-кодированная подпись из поля `signature`
   - Декодируется каноническая форма из подписанного payload
   - Выполняется проверка подписи с использованием публичного ключа и алгоритма, соответствующего `key_type`

5. **Результат**:
   - При успешной проверке: возвращается `202 Accepted`
   - При неудаче: возвращается `403 Forbidden` с описанием причины

## Обработка ошибок

### Типичные ошибки проверки подписи

1. **Checkpoint key not found** - публичный ключ для указанного `checkpointId` не найден в базе данных
2. **Invalid payload format** - подписанный payload не соответствует ожидаемому формату (отсутствует разделитель `|`)
3. **Signature verification failed** - подпись не соответствует канонической форме payload
4. **Verification error** - ошибка при декодировании или криптографических операциях

### Примеры ответов при ошибках

**Успех (202 Accepted):**
```json
{
  "status": "accepted",
  "checkpointId": "cp-1"
}
```

**Ошибка (403 Forbidden):**
```json
{
  "status": "rejected",
  "reason": "signature_verification_failed",
  "checkpointId": "cp-1"
}
```

## Безопасность

### Рекомендации

1. **Хранение закрытых ключей**: Закрытые ключи пропускных пунктов должны храниться в защищённом хранилище и никогда не передаваться в систему.

2. **Ротация ключей**: Регулярно обновляйте ключи пропускных пунктов. При смене ключа:
   - Сгенерируйте новую пару ключей
   - Обновите публичный ключ в таблице `checkpoint_keys`
   - Обновите ключ на пропускном пункте

3. **Длина ключей**:
   - RSA: минимум 2048 бит
   - ECDSA: минимум 256 бит (secp256r1 или secp256k1)

4. **Защита от replay-атак**: В будущих версиях будет добавлена защита от повторного использования подписей (см. Task-06: Anti-Replay).

## Проверка пользовательских токенов (userToken)

Система проверяет токены пользователей, выданные центрами выдачи (issuers). Токены используются для идентификации пользователей и содержат атрибуты доступа.

### Формат userToken

Токены пользователей передаются в формате **JWT (JSON Web Token)** или **JWS (JSON Web Signature)**.

**Структура JWT:**
```
header.payload.signature
```

Где:
- `header` - base64url-кодированный JSON заголовок, содержащий:
  - `alg` - алгоритм подписи (например, "RS256", "ES256")
  - `typ` - тип токена (обычно "JWT")
  - `kid` - идентификатор ключа (опционально)
- `payload` - base64url-кодированный JSON с claims:
  - `iss` (issuer) - обязательный, идентификатор центра выдачи
  - `sub` или `userId` - обязательный, идентификатор пользователя
  - `exp` - время истечения токена (Unix timestamp)
  - Дополнительные атрибуты (опционально)
- `signature` - цифровая подпись header и payload

**Пример токена:**
```
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJpc3N1ZXItMSIsInN1YiI6InVzZXItMTIzIiwiZXhwIjoxNzM2MDQ4MDAwfQ.signature...
```

### Политика валидации токенов

#### Обязательные поля

1. **`iss` (issuer)** - идентификатор центра выдачи
   - Должен присутствовать в payload
   - Используется для поиска публичного ключа в таблице `issuer_keys`
   - Если ключ не найден, токен отклоняется

2. **`sub` или `userId`** - идентификатор пользователя
   - Должен присутствовать в payload
   - Извлекается для дальнейшей обработки

3. **`exp` (expiration)** - время истечения токена
   - Проверяется автоматически библиотекой JWT
   - Просроченные токены отклоняются

#### Алгоритмы подписи

Поддерживаемые алгоритмы:
- **RS256** - RSA с SHA-256 (рекомендуется)
- **ES256** - ECDSA с SHA-256

Алгоритм указывается в поле `alg` заголовка токена и должен соответствовать алгоритму, указанному в таблице `issuer_keys` для данного issuer.

#### Проверка подписи

1. Извлекается `iss` из payload токена
2. По `iss` находится публичный ключ в таблице `issuer_keys`
3. Проверяется подпись токена с использованием публичного ключа
4. Проверяется соответствие алгоритма (`alg` в header должен соответствовать `algorithm` в БД)
5. Проверяется время истечения (`exp`)

### Структура таблицы `issuer_keys`

```sql
CREATE TABLE issuer_keys (
    id              UUID PRIMARY KEY,
    issuer_code     VARCHAR(128) NOT NULL UNIQUE,
    public_key_pem  TEXT         NOT NULL,
    key_type        VARCHAR(20)  NOT NULL DEFAULT 'RSA', -- 'RSA' or 'ECDSA'
    algorithm       VARCHAR(50)  NOT NULL DEFAULT 'RS256', -- 'RS256', 'ES256', etc.
    created_at      TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
    updated_at      TIMESTAMPTZ  NOT NULL DEFAULT NOW()
);
```

### Процесс проверки токена

1. **Парсинг токена**: Извлекаются header и payload для получения `iss` и `alg`
2. **Поиск ключа**: По `iss` находится публичный ключ в таблице `issuer_keys`
3. **Верификация подписи**: Проверяется подпись токена с использованием публичного ключа
4. **Проверка алгоритма**: Убеждаемся, что алгоритм токена соответствует ожидаемому
5. **Проверка срока действия**: Проверяется, что токен не истёк
6. **Извлечение данных**: Извлекаются `userId` и дополнительные атрибуты

### Обработка ошибок проверки токенов

1. **Issuer key not found** - публичный ключ для указанного `iss` не найден в базе данных
2. **Token missing 'iss' claim** - токен не содержит обязательного поля `iss`
3. **Token missing user identifier** - токен не содержит `sub` или `userId`
4. **Token expired** - токен истёк (проверка `exp`)
5. **JWT verification failed** - подпись токена не соответствует ожидаемой
6. **Algorithm mismatch** - алгоритм токена не соответствует алгоритму в БД
7. **Invalid token format** - токен не соответствует формату JWT

### Примеры ответов при ошибках проверки токена

**Ошибка (403 Forbidden):**
```json
{
  "status": "rejected",
  "reason": "token_verification_failed",
  "checkpointId": "cp-1",
  "token_error": "Token expired"
}
```

**Успех (202 Accepted):**
```json
{
  "status": "accepted",
  "checkpointId": "cp-1",
  "userId": "user-123"
}
```

### Рекомендации по безопасности токенов

1. **Срок действия токенов**: Устанавливайте разумное время жизни токенов (например, 1 час)
2. **Ротация ключей**: Регулярно обновляйте ключи центров выдачи
3. **Хранение закрытых ключей**: Закрытые ключи центров выдачи должны храниться в защищённом хранилище
4. **Длина ключей**:
   - RSA: минимум 2048 бит
   - ECDSA: минимум 256 бит (secp256r1 или secp256k1)
5. **Алгоритмы**: Используйте только RS256 или ES256 (избегайте HS256 и других симметричных алгоритмов)

## Реализация

### Основные компоненты

- `SignatureVerificationService` - сервис проверки подписей пропускных пунктов
- `CheckpointKeyRepository` - репозиторий для работы с ключами пропускных пунктов
- `CanonicalPayloadBuilder` - построитель канонической формы payload
- `IssuerTokenVerificationService` - сервис проверки JWT/JWS токенов пользователей
- `IssuerKeyRepository` - репозиторий для работы с ключами центров выдачи
- `IssuerTokenDecoderImpl` - реализация декодера токенов пользователей

### Зависимости

- BouncyCastle (`bcprov-jdk18on`, `bcpkix-jdk18on`) - для парсинга PEM-формата ключей
- JJWT (`jjwt-api`, `jjwt-impl`, `jjwt-jackson`) - для работы с JWT/JWS токенами

